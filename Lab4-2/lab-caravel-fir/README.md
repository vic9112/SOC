# Hardware FIR with CPU feeding data

## Update

| Date       | Description      |
| ---------- | ---------------- |
| 2025/04/12 | Update testbench / Upload firmware of each version |
| 2025/04/04 | Update RTL & Firmware |
| 2023/12/19 | Achieve 12T to process one data |
  
## The Firmware used in [caravel_la_fir_tb.v](https://github.com/bol-edu/soclab-reference-design/blob/f0083a4448f86898bf62b79c861fda5e6bf52009/lab-caravel-fir/testbench/counter_la_fir/counter_la_fir_tb.v#L289)
![螢幕擷取畫面 2025-04-12 012350](https://github.com/user-attachments/assets/86865a82-4040-41da-98b9-e19701a6f567)
- `counter_la_fir.hex`: generate after `source run_sim`
- [`originalfir.hex`](https://github.com/bol-edu/soclab-reference-design/blob/main/lab-caravel-fir/testbench/counter_la_fir/originalfir.hex): Original Caravel-FIR without any optimization with CPU <br>
  ![螢幕擷取畫面 2025-04-19 224125](https://github.com/user-attachments/assets/62d8cd9d-5124-4d5e-b87c-5ea1cef5161b)
- [`inst_cached.hex`](https://github.com/bol-edu/soclab-reference-design/blob/main/lab-caravel-fir/testbench/counter_la_fir/inst_cached.hex): Reduce the number of instructions to fit in the CPU cache <br>
  ![螢幕擷取畫面 2025-04-19 223923](https://github.com/user-attachments/assets/c52abfa2-6e13-4a24-ad2a-98d30e10c6ef)
- [`optimized##.hex`](https://github.com/bol-edu/soclab-reference-design/blob/main/lab-caravel-fir/testbench/counter_la_fir/optimized12.hex): Optimized(re-ordered) firmware with `tap_num = ##` <br>
  ![螢幕擷取畫面 2025-04-12 011925](https://github.com/user-attachments/assets/80639264-2427-4d02-b1c5-45e2031a7bd9)


## Change the test pattern and coefficient length:
- In [fir.h](https://github.com/bol-edu/soclab-reference-design/blob/4156d3c0602763ada68f3e82a1818de0db52f962/lab-caravel-fir/testbench/counter_la_fir/fir.h#L19) <br>
  ![螢幕擷取畫面 2025-04-12 013215](https://github.com/user-attachments/assets/f9a2a10c-157d-4584-8504-2a07c88badec)
- By changing the `H` in `fir.h`, the coefficient length in FIR firmware, hardware, testbench, and testpattern will change.


## Simulation for FIR

```sh
$ cd lab-caravel-fir/testbench/counter_la_fir
$ source run_clean
$ source run_sim
```
- Since I manual reorder instruction, this will generate firmware with instructions which are not re-ordered (counter_la_fir.hex)

## XSIM

```sh
$ make counter_la_fir
```
- which will generate xsim.log in the current directory. <br>
  ![螢幕擷取畫面 2025-04-12 011925](https://github.com/user-attachments/assets/a52103e4-6917-4667-ac9e-263919561249)


## Original Design / Bottleneck

During this lab, we encountered some problems caused by the latency of CPU access data:

![螢幕擷取畫面 2025-04-12 115350](https://github.com/user-attachments/assets/5b959821-b290-4500-aa74-8c434307a043)

- First, let's clarify some definitions.
  - Hardware calculate FIR (X->Y)
  - CPU fetch code from UserBRAM (Y->X)

- The part (`ss_tvalid & ss_tready` -> `sm_tvalid`) is the latency hardware calculating FIR (12T, tap_num=12)
- Then wait until CPU can receive Y (`sm_tready`).
- The part (`sm_tvalid & sm_tready` -> next `ss_tvalid`) is the latency CPU fetching the user project's code and writing the next X.
- Originally, calculate 1Y needs 240 cycles.

While our ability to make significant changes to the hardware is limited, there are still potential improvements we can make in optimizing the time it takes for the CPU to read assembly code:

- Let's take a look at the while loop in our original firmware code: <br>
  ![螢幕擷取畫面 2025-04-19 224418](https://github.com/user-attachments/assets/5f04baf1-fc83-4c71-b63f-7b28427c2efd)
- It generates the following assembly code([originalfir.out](https://github.com/bol-edu/soclab-reference-design/blob/main/lab-caravel-fir/testbench/counter_la_fir/originalfir.out)): <br>
  ![螢幕擷取畫面 2025-04-19 224719](https://github.com/user-attachments/assets/3844e4ad-5eac-4ab9-9790-f63a062123d4)
- But we only get the cache depth of 16 in our RISC-V CPU: <br>
  ![image](https://hackmd.io/_uploads/SkoA3lSFT.png)
- CPU has 16 instructions cache, but loop code has 18 instructions.

**So, our first goal is to shorten the assembly code**

### Optimization

![螢幕擷取畫面 2024-01-17 151008](https://hackmd.io/_uploads/By8PTlBKa.png )

- We can add the command -O2, -O3, -Ofast to optimize the assembly code generated by our riscv tool. The results are shown below:
  ![螢幕擷取畫面 2025-04-19 223923](https://github.com/user-attachments/assets/310fcdd0-009e-4db0-a1b9-eb6eccca8da9)
- Corresponding assembly code: <br>
  ![螢幕擷取畫面 2025-04-19 224844](https://github.com/user-attachments/assets/330926b0-4279-4e14-95ec-5a6b111329cf)
- Let's see the instruction write-X (`sw  a5 64(a3)`) to read-Y (`lw  a2 68(a3)`)
  - Takes latency for HW calculation
- In contrast, read-Y to write-X hardware does nothing, wait for X
- Let's see if we can start the loop by reading Y-out in the next part.

### **Futher Optimization**

- We can do further optimization by re-ordering some of the assembly codes.

- Original code: <br>
  ![螢幕擷取畫面 2025-04-12 122714](https://github.com/user-attachments/assets/0049aa81-1b43-41e3-8f65-512e1dbc088c)
  - `sw    a5,64(a3)`: store X
  - `lw    a2,68(a3)`: read Y
  - `addi  a5,a5,1  `: [t = t + 1](https://github.com/bol-edu/soclab-reference-design/blob/d5e53365fa0eaa2386181676c489b549c03bb724/lab-caravel-fir/testbench/counter_la_fir/fir.c#L30)
  - `addi  a4,a4,4  `: Increment the memory address([`outputsignal[t]`](https://github.com/bol-edu/soclab-reference-design/blob/d5e53365fa0eaa2386181676c489b549c03bb724/lab-caravel-fir/testbench/counter_la_fir/fir.h#L26)) corresponding to `t`
  - `sw   a2.-4(a4) `: Store the Y value into `outputsignal[t]`
- Start the loop from reading Y-out and re-order to the following result: <br>
  ![螢幕擷取畫面 2025-04-12 124142](https://github.com/user-attachments/assets/0a87df4b-f586-4b5a-8ab0-c7f0f486a862)
  - Prevent load-to-use

- **Result** <br>
  ![螢幕擷取畫面 2025-04-12 124405](https://github.com/user-attachments/assets/cb859cdf-ee4d-41dd-923c-ce0c09a45e8c) <br>
  ![螢幕擷取畫面 2025-04-12 011925](https://github.com/user-attachments/assets/087761a7-f751-4be2-9b40-b219c51e3481)



